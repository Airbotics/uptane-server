generator client {
    provider            = "prisma-client-js"
    previewFeatures     = ["interactiveTransactions"]
}

datasource db {
    provider            = "postgresql"
    url                 = env("POSTGRES_CONN_STR")
}

// upload status of an object/image
enum UploadStatus {
    uploading
    uploaded
}

// status of a certifcate 
enum CertificateStatus {
    issuing         // waiting for pca to issue
    issued          // sent to the client
    expired         // naturally expired
    revoked         // user explicity revoked (can only do this if status is issued)
}

// type of a certificate
enum CertificateType {
    provisioning    // for aktualizr to provision primary ecu
    client          // for garage sign
    robot           // used by a provisioned robot for regular coms
}

// type of tuf repo
enum TUFRepo {
    director
    image
}

// type of tuf role
enum TUFRole {
    root
    targets
    snapshot
    timestamp
}

// status of static delta generation
enum StaticDeltaStatus {
    underway
    failed
    succeeded
}

// type/format of image
enum ImageFormat {
    ostree
    binary                                                      // this is not supported for now
}

// a team of users, a team is the owner of all resources
model Team {
    id                  String          @id @default(uuid()) @unique
    name                String
    num_members         Int             @default(1)
    created_at          DateTime        @default(now())
    updated_at          DateTime        @updatedAt

    refs                Ref[]
    objects             Object[]
    deltas              StaticDelta[]
    images              Image[]
    tuf_metadata        TufMetadata[]
    robots              Robot[]
    ecus                Ecu[]
    robot_manifests     RobotManifest[]
    network_reports     NetworkReport[]
    packages_reports    InstalledPackagesReport[]
    hw_info_reports     HardwareInfoReport[]
    akt_config_reports  AktualizrConfigReport[]
    ecu_telemetry       EcuTelemetry[]
    provisioning_creds  ProvisioningCredentials[]
    groups              Group[]
    robot_groups        RobotGroup[]
    rollouts            Rollout[]
    certificates        Certificate[]

    @@map("teams")
}


// provisioning credentials
// TODO add in the account that downloaded/revoked it
model ProvisioningCredentials {
    id                  String          @id @default(uuid()) @unique
    name                String
    team_id             String
    created_at          DateTime        @default(now())
    status              CertificateStatus   @default(issuing)   // combination of status as certs
    expires_at          DateTime                                // will be the same as certs
    revoked_at          DateTime?                               // will be the same as certs
    client_cert_id      String
    provisioning_cert_id     String

    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)

    client_cert         Certificate     @relation(name: "client", fields: [team_id, client_cert_id], references: [team_id, id], onDelete: Cascade)
    provisioning_cert   Certificate     @relation(name: "prov", fields: [team_id, provisioning_cert_id], references: [team_id, id], onDelete: Cascade)

    @@unique([team_id, id])
    @@unique([team_id, client_cert_id])
    @@unique([team_id, provisioning_cert_id])
    @@map("provisioning_credentials")
}



// a record of certs that we have issued
model Certificate {
    id                  String          @default(uuid())
    team_id             String
    serial              String          @unique
    acm_arn             String?
    created_at          DateTime        @default(now())
    expires_at          DateTime
    revoked_at          DateTime?
    revoked_reason      String?
    status              CertificateStatus   @default(issuing)
    cert_type           CertificateType
    robot_id            String?

    client_creds        ProvisioningCredentials? @relation("client")
    provisioning_creds  ProvisioningCredentials? @relation("prov")
    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)
    robot               Robot?          @relation(fields: [robot_id], references: [id], onDelete: Cascade)

    @@id([team_id, id])
    @@map("certificates")
}


// images stored in image repo
model Image {
    id                  String          @id @default(uuid()) @unique
    team_id             String
    name                String                                  // human readable name
    description         String?
    size                Int                                     // size of image in bytes
    sha256              String          @unique                 // sha256 hash of image
    hwids               String[]                                // types/ids of ecu hardware this image can be deployed to
    status              UploadStatus                            // uploading or uploaded
    format              ImageFormat                             // type of image (binary or ostree)
    created_at          DateTime        @default(now())
    updated_at          DateTime        @updatedAt

    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)

    ecus                Ecu[]
    rollout_image       RolloutHardwareImage[]

    @@unique([team_id, id])
    @@map("images")
}


// tuf metadata
model TufMetadata {
    id                  String          @id @default(uuid()) @unique
    team_id             String
    robot_id            String?                                 // which robot does the snapshot, timestamp and target apply to (director only)
    role                TUFRole                                 // director or image repo
    repo                TUFRepo                                 // root, targets, snapshot or timestamp
    version             Int                                     // must match the version in the signed portion of the metadata
    value               Json                                    // holds the canonicalised signed metadata
    created_at          DateTime        @default(now())
    expires_at          DateTime                                // this should always match the 'expires' field in the signed portion

    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)
    robot               Robot?          @relation(fields: [robot_id], references: [id], onDelete: Cascade)
    
    //TODO: Add the following conditional unique constraint when prisma implement it
    // @@unique([team_id, repo, role, version], where: {repo: TUFRepo.image})
    // @@unique([team_id, repo, role, version, robot_id], where: {repo: TUFRepo.director})
    //Keep an eye on issue here: https://github.com/prisma/prisma/issues/6974
    @@map("tuf_metadata")
}


// robots on which Airbotics will update software
// these are called vehicles in the Update spec
// TODO
// - add provisioned field denoting whether it is provisioned
// - add a list of certificates
model Robot {
    id                  String          @id @default(uuid()) @unique
    team_id             String
    name                String?
    description         String?
    agent_version       String?                             // the version of the agent running on the primary ecu
    last_seen_at        DateTime?                           // the last time this robot was seen at
    ecus_registered     Boolean         @default(false)     // whether the ecus have been registered, they can only do this once
    created_at          DateTime        @default(now())
    updated_at          DateTime        @updatedAt

    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)

    ecus                Ecu[]
    robot_manifests     RobotManifest[]
    tuf_metadata        TufMetadata[]
    network_reports     NetworkReport[]
    packages_reports    InstalledPackagesReport[]
    hw_info_reports     HardwareInfoReport[]
    akt_config_reports  AktualizrConfigReport[]

    groups              RobotGroup[]
    rollouts            RolloutRobot[]
    certificates        Certificate[]

    @@unique([team_id, id])
    @@map("robots")
}


// ecus in robots
model Ecu {
    id                  String          @id @default(uuid()) @unique        // equivalent to ecu serial
    team_id             String
    robot_id            String
    hwid                String                              // hardware type/id of this ecu
    primary             Boolean                             // whether this ecu is the primary, only one per robot is supported
    image_id            String?                             // FK to whichever image is currently installed
    created_at          DateTime        @default(now())
    updated_at          DateTime        @updatedAt

    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)
    robot               Robot           @relation(fields: [team_id, robot_id], references: [team_id, id], onDelete: Cascade)
    installed_image     Image?          @relation(fields: [team_id, image_id], references: [team_id, id], onDelete: Cascade)
   
    telemetry           EcuTelemetry[]

    @@unique([team_id, id])
    @@map("ecus")
}

// a network report from a robot
model NetworkReport {
    id                  String          @id @default(uuid()) @unique
    team_id             String
    robot_id            String
    hostname            String?
    local_ipv4          String?
    mac                 String?
    created_at          DateTime        @default(now())
    updated_at          DateTime        @updatedAt

    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)
    robot               Robot           @relation(fields: [team_id, robot_id], references: [team_id, id], onDelete: Cascade)

    @@unique([team_id, id])
    @@map("network_reports")
}

// installed packages report from a robot
model InstalledPackagesReport {
    id                  String          @id @default(uuid()) @unique
    team_id             String
    robot_id            String
    packages            Json                                // stored as a json field
    created_at          DateTime        @default(now())
    updated_at          DateTime        @updatedAt

    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)
    robot               Robot           @relation(fields: [team_id, robot_id], references: [team_id, id], onDelete: Cascade)

    @@unique([team_id, id])
    @@map("installed_packages_reports")
}

// aktualizr config report from a robot
model AktualizrConfigReport {
    id                  String          @id @default(uuid()) @unique
    team_id             String
    robot_id            String
    config              Json                                // stored as a json field
    created_at          DateTime        @default(now())
    updated_at          DateTime        @updatedAt

    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)
    robot               Robot           @relation(fields: [team_id, robot_id], references: [team_id, id], onDelete: Cascade)

    @@unique([team_id, id])
    @@map("aktualizr_config_reports")
}

// hardware info report from a robot
model HardwareInfoReport {
    id                  String          @id @default(uuid()) @unique
    team_id             String
    robot_id            String
    hardware_info       Json                                // stored as a json field
    created_at          DateTime        @default(now())
    updated_at          DateTime        @updatedAt

    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)
    robot               Robot           @relation(fields: [team_id, robot_id], references: [team_id, id], onDelete: Cascade)

    @@unique([team_id, id])
    @@map("hardware_info_reports")
}

// telemetry events sent by an ecu
model EcuTelemetry {
    id                  String          @id @default(uuid()) @unique
    team_id             String
    ecu_id              String

    event_type          String
    device_time         DateTime
    success             Boolean?
    created_at          DateTime        @default(now())

    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)
    ecu                 Ecu             @relation(fields: [team_id, ecu_id], references: [team_id, id], onDelete: Cascade)

    @@unique([team_id, id])
    @@map("ecu_telemetry")
}


// robot manifests sent by primaries
model RobotManifest {
    id                  String          @default(uuid())
    team_id             String
    robot_id            String
    value               Json            // holds entire signed manifest
    valid               Boolean
    created_at          DateTime        @default(now())

    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)
    robot               Robot           @relation(fields: [team_id, robot_id], references: [team_id, id], onDelete: Cascade)

    @@id([team_id, id])
    @@map("robot_manifests")
}



// ostree references
model Ref {
    name                String
    commit              String                                  // commit hash
    object_id           String                                  // object it points to
    team_id             String
    created_at          DateTime        @default(now())
    updated_at          DateTime        @updatedAt

    object              Object          @relation(fields: [team_id, object_id], references: [team_id, object_id], onDelete: Cascade)
    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)

    @@id([team_id, name])
    @@map("refs")
}


// ostree object
// TODO rename object_id to id
model Object {
    object_id           String
    team_id             String
    size                Int                                     // size of object in bytes
    status              UploadStatus
    created_at          DateTime        @default(now())
    updated_at          DateTime        @updatedAt

    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)
    refs                Ref[]
    from_deltas         StaticDelta[]   @relation(name: "DeltaFrom")
    to_deltas           StaticDelta[]   @relation(name: "DeltaTo")


    @@id([team_id, object_id])
    @@map("objects")
}

// ostree static deltas
model StaticDelta {
    from                String
    to                  String
    team_id             String
    created_at          DateTime        @default(now())
    updated_at          DateTime        @updatedAt
    status              StaticDeltaStatus @default(underway)

    from_delta          Object          @relation(name: "DeltaFrom", fields: [team_id, from], references: [team_id, object_id], onDelete: Cascade)
    to_delta            Object          @relation(name: "DeltaTo", fields: [team_id, to], references: [team_id, object_id], onDelete: Cascade)
    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)

    @@id([team_id, from, to])
    @@map("static_deltas")
}


// groups that a robot can be in
model Group {
    id                  String          @id @default(uuid()) @unique
    name                String
    description         String
    team_id             String
    created_at          DateTime        @default(now())
 
    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)
    
    robots              RobotGroup[]

    @@unique([id, team_id])
    @@map("groups")
}

// mappings between a robot and which groups they are in
model RobotGroup {
    robot_id            String
    group_id            String
    team_id             String
    created_at          DateTime        @default(now())

    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)
    robot               Robot           @relation(fields: [robot_id], references: [id], onDelete: Cascade)
    group               Group           @relation(fields: [group_id], references: [id], onDelete: Cascade)

    @@id([team_id, robot_id, group_id])
    @@map("robot_groups")
}


// ---------------- ROLLOUTS ---------------- //


enum RolloutStatus {
    preparing
    launched
    finished
    cancelled
}


model Rollout {
    id                  String          @id @default(uuid()) @unique
    team_id             String
    name                String
    description         String
    status              RolloutStatus   @default(preparing)

    created_at          DateTime        @default(now())
    updated_at          DateTime        @default(now())

    team                Team            @relation(fields: [team_id], references: [id], onDelete: Cascade)

    cancelled           RolloutsCancelled[]
    robots              RolloutRobot[]
    hw_imgs             RolloutHardwareImage[]

    @@unique([id, team_id])
    @@map("rollouts")
}


model RolloutsCancelled {
    rollout_id          String          @unique
    status              String

    created_at          DateTime        @default(now())
    updated_at          DateTime        @default(now())

    rollout             Rollout         @relation(fields: [rollout_id], references: [id], onDelete: Cascade)


    @@map("rollouts_cancelled")
}
 

model RolloutHardwareImage {
    id                  String          @id @default(uuid()) @unique
    rollout_id          String
    hw_id               String
    image_id            String?

    created_at          DateTime        @default(now())

    image               Image?          @relation(fields: [image_id], references: [id], onDelete: SetNull)
    rollout             Rollout         @relation(fields: [rollout_id], references: [id], onDelete: Cascade)
    
    @@unique([rollout_id, hw_id, image_id])
    @@map("rollout_hardware_images")
}


enum RolloutRobotStatus {
    pending             // rollout created but worker hasn’t got around to processing
    skipped             // worker determined update is n/a for bot
    scheduled           // worker has created the latest targets.json in the director repo
    accepted            // robot has acknowledged the update
    successful          // robot has successfully pulled the update
    cancelled           // the rollout was cancelled
    failed              // robot tried and failed to pull the update
}


model RolloutRobot {
    id                  String              @id @default(uuid()) @unique
    rollout_id          String
    robot_id            String?
    status              RolloutRobotStatus  @default(pending) 
    result_desc         String?

    created_at          DateTime            @default(now())
    updated_at          DateTime            @default(now())

    rollout             Rollout             @relation(fields: [rollout_id], references: [id], onDelete: Cascade)
    robot               Robot?              @relation(fields: [robot_id], references: [id], onDelete: SetNull)
    
    @@unique([rollout_id, robot_id])
    @@map("rollout_robots")
}